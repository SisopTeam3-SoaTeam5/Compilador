package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.*;
import lyc.compiler.model.*;
import lyc.compiler.factories.GCIFactory;
import java.util.ArrayList;
import java.util.HashMap;
class Parser;

action code {:
    GCIFactory gci=new GCIFactory();
    SymbolTable st = new SymbolTable();
:}

// Terminals
terminal INIT;
terminal INTEGER;
terminal FLOAT;
terminal STRING;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal WRITE;
terminal READ;
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;
terminal STRING_CONSTANT;
terminal IDENTIFIER;
terminal GREATER_THAN;
terminal LESS_THAN;
terminal GREATER_OR_EQUAL;
terminal LESS_OR_EQUAL;
terminal NOT_EQUAL;
terminal EQUAL;
terminal NOT;
terminal AND;
terminal OR;
terminal OPEN_BLOCK;
terminal CLOSE_BLOCK;
terminal COMMA;
terminal SEMICOLON;
terminal DO;
terminal ENDDO;
terminal CASE;
terminal DEFAULT;
terminal ALLEQUAL;
terminal SQUARE_OPEN_BRACKET;
terminal SQUARE_CLOSE_BRACKET;

// Non Terminals
non terminal sta;
non terminal programa;
non terminal bloquecod;
non terminal bloquedec;
non terminal declaraciones;
non terminal sentencia;
non terminal linea;
non terminal pregunta;
non terminal preguntaElse;
non terminal loop;
non terminal declaracion;
non terminal list_identifier;
non terminal asignacion;
non terminal escritura;
non terminal lectura;
non terminal type;
non terminal comparacion;
non terminal comparador;
non terminal expression;
non terminal term;
non terminal factor;
non terminal logical;
non terminal condicion;
non terminal condicionWhile;
non terminal startswitch;
non terminal switch;
non terminal lista_casos;
non terminal all_equal;
non terminal all_equal_params;
non terminal array_expresiones;
non terminal lista_expresiones;

// Start Symbol Definition
start with sta;



sta ::= programa {: FileOutputWriter.writeOutput("final.asm", new AsmCodeGenerator());:};
programa ::= bloquecod {: System.out.println("programa ::= bloquecod"); :};
programa ::= bloquedec {: System.out.println("programa ::= bloquedec"); :};
programa ::= bloquedec bloquecod {: System.out.println("programa ::= bloquedec bloquecod"); :};
bloquedec ::= INIT OPEN_BLOCK declaraciones CLOSE_BLOCK {: System.out.println("bloquedec ::= INIT OPEN_BLOCK declaraciones CLOSE_BLOCK"); :};
declaraciones ::= declaracion {: System.out.println("declaraciones ::= declaracion"); :};
declaraciones ::= declaraciones declaracion {: System.out.println("declaraciones ::= declaraciones declaracion"); :};
bloquecod ::= sentencia {: System.out.println("bloquecod ::= sentencia"); :};
bloquecod ::= bloquecod sentencia {: System.out.println("bloquecod ::= bloquecod sentencia"); :};
sentencia ::= linea SEMICOLON {: System.out.println("sentencia ::= linea SEMICOLON"); :};
sentencia ::= pregunta {: gci.endIf(0,true); :};
sentencia ::= preguntaElse;
sentencia ::= loop {: System.out.println("sentencia ::= loop"); :};
sentencia ::= switch {: System.out.println("sentencia ::= switch"); :};
linea ::= asignacion {: System.out.println("linea ::= asignacion"); :};
linea ::= escritura {: System.out.println("linea ::= escritura"); :};
linea ::= lectura {: System.out.println("linea ::= lectura"); :};
declaracion ::= list_identifier ASSIG type SEMICOLON {:System.out.println("declaracion ::= list_identifier ASSIG type SEMICOLON");:};
list_identifier ::= IDENTIFIER:id {:System.out.println("list_identifier ::= IDENTIFIER"+id); :};
list_identifier ::= list_identifier COMMA IDENTIFIER:id {: System.out.println("list_identifier ::= IDENTIFIER COMMA list_identifier"); :};
type ::= INTEGER                {: System.out.println("type ::= INTEGER"); :};
type ::= FLOAT                  {: System.out.println("type ::= FLOAT"); :}; // Falta Revisar que los tipos de datos sean correctos
type ::= STRING                 {: System.out.println("type ::= STRING"); :};
asignacion ::= IDENTIFIER:id ASSIG expression {:
                                                System.out.println(id+" Es "+ st.findVariableType(id.toString()));
                                                if(st.findVariableType(id.toString())!="Float" && st.findVariableType(id.toString())!="Integer"){
                                                    throw new InvalidTypeException(id+" No es compatible con tipos Integer o Float");
                                                }
                                                gci.insertarTerceto("Asigind",new Terceto("=",id.toString(), gci.GCIVariables.get("Eind"))); :};
asignacion ::= IDENTIFIER:id ASSIG STRING_CONSTANT:str {:
                                                if(st.findVariableType(id.toString())!="String"){
                                                    throw new InvalidTypeException(id+" No es compatible con tipo String");
                                                }
 gci.insertarTerceto(new Terceto("=",id.toString(), str.toString())); :};
asignacion ::= IDENTIFIER:id ASSIG condicion {: System.out.println("asignoCond");gci.assignCond(id.toString()); :};
escritura ::= WRITE STRING_CONSTANT  {: System.out.println("escritura ::= WRITE STRING_CONSTANT"); :}; // Falta Preguntas a los profes
escritura ::= WRITE expression  {: System.out.println("escritura ::= WRITE expression"); :}; //Preguntas a los profes
lectura ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET {: System.out.println("lectura ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET"); :}; //Preguntas a los profes

pregunta ::= IF OPEN_BRACKET  condicion CLOSE_BRACKET {: gci.setComparator(null); :} OPEN_BLOCK {:gci.startIf();:} bloquecod CLOSE_BLOCK;
preguntaElse ::= pregunta {: gci.endIf(1,false);gci.pushCell();gci.beforeElse();:} ELSE OPEN_BLOCK bloquecod CLOSE_BLOCK  {: gci.endElse(); :};


loop ::= WHILE OPEN_BRACKET {:
gci.insertarTerceto(new Terceto("et_WHILE_" + gci.whileCount++));
gci.whileStack.push(gci.tercetos.size());
:} condicionWhile  CLOSE_BRACKET OPEN_BLOCK {:gci.startLoop();:} bloquecod CLOSE_BLOCK {: gci.endLoop();:};
startswitch ::= DO IDENTIFIER:id {:gci.pushSwitchId(id.toString());:} lista_casos {: gci.setSwitchBranch();:};
switch ::=  startswitch DEFAULT bloquecod ENDDO {: gci.pushSwitchEndBlockCell(); :};
switch ::= startswitch ENDDO {: gci.pushSwitchEndBlockCell(); :};
lista_casos ::= lista_casos CASE {:gci.incCasesCount(); gci.setSwitchBranch();:} comparacion {: gci.validateSwitchId();gci.pushSwitchCell(); gci.insertBranch(); :} bloquecod {: gci.pushSwitchInconditionalCell(); gci.insertarTerceto(new Terceto("BI")); :};
lista_casos ::= CASE{:gci.newSwitch();:} comparacion {:gci.validateSwitchId(); gci.pushSwitchCell(); gci.insertBranch(); :} bloquecod {: gci.pushSwitchInconditionalCell(); gci.insertarTerceto(new Terceto("BI")); :};
all_equal ::= ALLEQUAL OPEN_BRACKET all_equal_params {: gci.resolverAllEq(); :} CLOSE_BRACKET {: System.out.println("all_equal ::= ALLEQUAL OPEN_BRACKET all_equal_params CLOSE_BRACKET"); :}; //sobra???
all_equal_params ::= all_equal_params COMMA array_expresiones {: gci.compararListasExp(); :};
all_equal_params ::= array_expresiones COMMA array_expresiones {: gci.compararListasExp(); :};
array_expresiones ::= SQUARE_OPEN_BRACKET lista_expresiones {: gci.setListAFull(true);  :} SQUARE_CLOSE_BRACKET {: System.out.println("array_expresiones ::= SQUARE_OPEN_BRACKET lista_expresiones SQUARE_CLOSE_BRACKET "); :};
lista_expresiones ::= lista_expresiones COMMA expression {: gci.addToList(gci.tercetos.size()-1); :};
lista_expresiones ::= expression {: gci.addToList(gci.tercetos.size()-1); :};
condicion ::= comparacion {: gci.pushCell(); gci.insertBranch(); gci.pushLogical(null);:};
condicionWhile ::=  comparacion {:  gci.pushCell(); gci.insertBranch(); gci.pushLogical(null);:};
condicion ::= comparacion logical {: gci.pushCell(); gci.insertBranch(1);:} comparacion {: gci.pushCell(); gci.insertBranch(2);System.out.println("logic comp");:};
condicionWhile ::=  comparacion logical {: gci.pushCell(); gci.insertBranch(1);:} comparacion {: gci.pushCell(); gci.insertBranch(2);:};
comparacion ::= NOT comparacion {: gci.revertComparator(); gci.pushLogical(null); :} ;       //cambio-> para que se puedan negar las comparaciones individuales
logical ::= AND {:gci.pushLogical("and");:}  | OR{:gci.pushLogical("or");:}  ;
comparacion ::= expression {:gci.eStack.push(gci.GCIVariables.get("Eind"));:}comparador expression {: gci.insertarTerceto("Cind",new Terceto("CMP",gci.eStack.pop(),gci.getVariable("Eind"))); :};
comparacion ::= all_equal {: gci.setComparator("BNE"); gci.insertarTerceto(new Terceto("CMP","1","@allEq")); :};
comparador ::= GREATER_THAN{:gci.setComparator("BLE"); System.out.println("setcmp");:} | LESS_THAN{:gci.setComparator("BGE");:} | GREATER_OR_EQUAL{:gci.setComparator("BLT");:} | LESS_OR_EQUAL {:gci.setComparator("BGT");:}| NOT_EQUAL {:gci.setComparator("BEQ");:}| EQUAL {:gci.setComparator("BNE");:};
expression ::= expression PLUS term {: gci.insertarTerceto("Eind",new Terceto("+", gci.GCIVariables.get("Eind").toString(), gci.GCIVariables.get("Tind").toString())); :};
expression ::= expression SUB term {: gci.insertarTerceto("Eind",new Terceto("-", gci.GCIVariables.get("Eind").toString(), gci.GCIVariables.get("Tind").toString()));  :};
expression ::= term {: gci.asignarVarind("Eind","Tind");:};
term ::= term MULT factor {: gci.insertarTerceto("Tind",new Terceto("*", gci.getVariable("Tind").toString(), gci.getVariable("Find").toString()));  :};
term ::= term DIV factor {: gci.insertarTerceto("Tind",new Terceto("/", gci.getVariable("Tind").toString(), gci.getVariable("Find").toString())); :};
term ::= factor {:gci.asignarVarind("Tind","Find");:};
factor ::= IDENTIFIER:id  {: if(st.findVariableType(id.toString())!="Float" && st.findVariableType(id.toString())!="Integer"){
                                  throw new InvalidTypeException(id+" No es compatible con tipos Integer o Float");
                                }
                                gci.insertarTerceto("Find",new Terceto(id.toString())); :};
factor ::= INTEGER_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto("_"+constant.toString())); :};
factor ::= SUB INTEGER_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto( "-" + constant.toString())); :};
factor ::= FLOAT_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto("_"+constant.toString())); :};
factor ::= SUB FLOAT_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto( "-" + constant.toString())); :};
factor ::= OPEN_BRACKET {: gci.eStack.push(gci.GCIVariables.get("Eind"));
                           gci.tStack.push(gci.GCIVariables.get("Tind"));:} expression:e CLOSE_BRACKET {: gci.asignarVarind("Find","Eind"); gci.asignarVarind("Eind", gci.eStack); gci.asignarVarind("Tind", gci.tStack); :};
