package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.*;
import lyc.compiler.model.*;
import lyc.compiler.factories.GCIFactory;
import java.util.ArrayList;
import java.util.HashMap;
class Parser;

action code {:
    GCIFactory gci=new GCIFactory();
:}

// Terminals
terminal INIT;
terminal INTEGER;
terminal FLOAT;
terminal STRING;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal WRITE;
terminal READ;
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;
terminal STRING_CONSTANT;
terminal IDENTIFIER;
terminal GREATER_THAN;
terminal LESS_THAN;
terminal GREATER_OR_EQUAL;
terminal LESS_OR_EQUAL;
terminal NOT_EQUAL;
terminal EQUAL;
terminal NOT;
terminal AND;
terminal OR;
terminal OPEN_BLOCK;
terminal CLOSE_BLOCK;
terminal COMMA;
terminal SEMICOLON;
terminal DO;
terminal ENDDO;
terminal CASE;
terminal DEFAULT;
terminal ALLEQUAL;
terminal SQUARE_OPEN_BRACKET;
terminal SQUARE_CLOSE_BRACKET;

// Non Terminals
non terminal sta;
non terminal programa;
non terminal bloquecod;
non terminal bloquedec;
non terminal declaraciones;
non terminal sentencia;
non terminal linea;
non terminal pregunta;
non terminal preguntaelse;
non terminal loop;
non terminal declaracion;
non terminal list_identifier;
non terminal asignacion;
non terminal escritura;
non terminal lectura;
non terminal type;
non terminal comparacion;
non terminal comparador;
non terminal expression;
non terminal term;
non terminal factor;
non terminal logical;
non terminal condicion;
non terminal switch;
non terminal lista_casos;
non terminal all_equal;
non terminal all_equal_params;
non terminal array_expresiones;
non terminal lista_expresiones;

// Start Symbol Definition
start with sta;



sta ::= programa {: /*gci.printTercetos();*/
System.out.println(gci.allEqListA);
System.out.println(gci.allEqListB);
:};
programa ::= bloquecod {: System.out.println("programa ::= bloquecod"); :};
programa ::= bloquedec {: System.out.println("programa ::= bloquedec"); :};
programa ::= bloquedec bloquecod {: System.out.println("programa ::= bloquedec bloquecod"); :};
bloquedec ::= INIT OPEN_BLOCK declaraciones CLOSE_BLOCK {: System.out.println("bloquedec ::= INIT OPEN_BLOCK declaraciones CLOSE_BLOCK"); :};
declaraciones ::= declaracion {: System.out.println("declaraciones ::= declaracion"); :};
declaraciones ::= declaraciones declaracion {: System.out.println("declaraciones ::= declaraciones declaracion"); :};
bloquecod ::= sentencia {: System.out.println("bloquecod ::= sentencia"); :};
bloquecod ::= bloquecod sentencia {: System.out.println("bloquecod ::= bloquecod sentencia"); :};
sentencia ::= linea SEMICOLON {: System.out.println("sentencia ::= linea SEMICOLON"); :};
sentencia ::= pregunta {: System.out.println("sentencia ::= pregunta"); :};
sentencia ::= loop {: System.out.println("sentencia ::= loop"); :};
sentencia ::= switch {: System.out.println("sentencia ::= switch"); :};
linea ::= asignacion {: System.out.println("linea ::= asignacion"); :};
linea ::= escritura {: System.out.println("linea ::= escritura"); :};
linea ::= lectura {: System.out.println("linea ::= lectura"); :};
declaracion ::= list_identifier ASSIG type SEMICOLON {:System.out.println("declaracion ::= list_identifier ASSIG type SEMICOLON");:};
list_identifier ::= IDENTIFIER:id {:System.out.println("list_identifier ::= IDENTIFIER"+id); :};
list_identifier ::= list_identifier COMMA IDENTIFIER:id {: System.out.println("list_identifier ::= IDENTIFIER COMMA list_identifier"); :};
type ::= INTEGER                {: System.out.println("type ::= INTEGER"); :};
type ::= FLOAT                  {: System.out.println("type ::= FLOAT"); :};
type ::= STRING                 {: System.out.println("type ::= STRING"); :};
asignacion ::= IDENTIFIER:id ASSIG expression {: gci.insertarTerceto("Asigind",new Terceto("=",id.toString(), gci.GCIVariables.get("Eind"))); :};
asignacion ::= IDENTIFIER:id ASSIG STRING_CONSTANT:str {: System.out.println("asignacion ::= IDENTIFIER ASSIG STRING_CONSTANT"); :};
asignacion ::= IDENTIFIER ASSIG condicion {: System.out.println("asignacion ::= IDENTIFIER ASSIG STRING_CONSTANT"); :};
escritura ::= WRITE STRING_CONSTANT  {: System.out.println("escritura ::= WRITE STRING_CONSTANT"); :};
escritura ::= WRITE expression  {: System.out.println("escritura ::= WRITE expression"); :};
lectura ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET {: System.out.println("lectura ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET"); :};

pregunta ::= IF OPEN_BRACKET  condicion CLOSE_BRACKET {: gci.setComparator(null); :} OPEN_BLOCK {:gci.startIf();:} bloquecod CLOSE_BLOCK {: gci.endIf(); :};
preguntaelse ::= pregunta ELSE OPEN_BLOCK bloquecod CLOSE_BLOCK  {: System.out.println("pregunta ::= IF OPEN_BRACKET condicion CLOSE_BRACKET OPEN_BLOCK bloquecod CLOSE_BLOCK ELSE OPEN_BLOCK bloquecod CLOSE_BLOCK"); :};


loop ::= WHILE OPEN_BRACKET condicion CLOSE_BRACKET OPEN_BLOCK bloquecod CLOSE_BLOCK {: System.out.println("loop ::= WHILE OPEN_BRACKET condicion CLOSE_BRACKET OPEN_BLOCK bloquecod CLOSE_BLOCK"); :};
switch ::= DO IDENTIFIER lista_casos DEFAULT bloquecod ENDDO {: System.out.println("switch ::= DO IDENTIFIER lista_casos DEFAULT bloquecod ENDDO"); :};
switch ::= DO IDENTIFIER lista_casos ENDDO {: System.out.println("switch ::= DO IDENTIFIER lista_casos ENDDO"); :};
lista_casos ::= lista_casos CASE comparacion bloquecod {: System.out.println("lista_casos ::= lista_casos CASE comparacion bloquecod"); :};
lista_casos ::= CASE comparacion bloquecod {: System.out.println("lista_casos ::= CASE comparacion bloquecod"); :};
all_equal ::= ALLEQUAL OPEN_BRACKET all_equal_params CLOSE_BRACKET {: System.out.println("all_equal ::= ALLEQUAL OPEN_BRACKET all_equal_params CLOSE_BRACKET"); :}; //sobra???
all_equal_params ::= all_equal_params COMMA array_expresiones {: System.out.println("all_equal_params ::= all_equal_params COMMA array_expresiones"); :};
all_equal_params ::= array_expresiones COMMA array_expresiones {: gci.compararListasExp(); :};
array_expresiones ::= SQUARE_OPEN_BRACKET lista_expresiones {: gci.setListAFull(true);  :} SQUARE_CLOSE_BRACKET {: System.out.println("array_expresiones ::= SQUARE_OPEN_BRACKET lista_expresiones SQUARE_CLOSE_BRACKET "); :};
lista_expresiones ::= lista_expresiones COMMA expression {: gci.addToList(gci.tercetos.size()-1); :};
lista_expresiones ::= expression {: gci.addToList(gci.tercetos.size()-1); :};
condicion ::= comparacion {: gci.pushCell(); gci.insertBranch(); gci.pushLogical(null);:};
condicion ::= comparacion logical {:gci.pushCell(); gci.insertBranch(1);:} comparacion {: gci.pushCell(); gci.insertBranch(2);:};
comparacion ::= NOT comparacion {: gci.revertComparator(); gci.pushLogical(null); :} ;       //cambio-> para que se puedan negar las comparaciones individuales
logical ::= AND {:gci.pushLogical("and");:}  | OR{:gci.pushLogical("or");:}  ;
comparacion ::= expression {:gci.eStack.push(gci.GCIVariables.get("Eind"));:}comparador expression {: gci.insertarTerceto("Cind",new Terceto("CMP",gci.eStack.pop(),gci.getVariable("Eind")));:};
comparacion ::= all_equal {: System.out.println("comparacion ::= expression comparador expression"); :};
comparador ::= GREATER_THAN{:gci.setComparator("BLE"); System.out.println("setcmp");:} | LESS_THAN{:gci.setComparator("BGE");:} | GREATER_OR_EQUAL{:gci.setComparator("BLT");:} | LESS_OR_EQUAL {:gci.setComparator("BGT");:}| NOT_EQUAL {:gci.setComparator("BEQ");:}| EQUAL {:gci.setComparator("BNE");:};
expression ::= expression PLUS term {: gci.insertarTerceto("Eind",new Terceto("+", gci.GCIVariables.get("Eind").toString(), gci.GCIVariables.get("Tind").toString())); :};
expression ::= expression SUB term {: gci.insertarTerceto("Eind",new Terceto("-", gci.GCIVariables.get("Eind").toString(), gci.GCIVariables.get("Tind").toString()));  :};
expression ::= term {: gci.asignarVarind("Eind","Tind");:};
term ::= term MULT factor {: gci.insertarTerceto("Tind",new Terceto("*", gci.getVariable("Tind").toString(), gci.getVariable("Find").toString()));  :};
term ::= term DIV factor {: gci.insertarTerceto("Tind",new Terceto("/", gci.getVariable("Tind").toString(), gci.getVariable("Find").toString())); :};
term ::= factor {:gci.asignarVarind("Tind","Find");:};
factor ::= IDENTIFIER:id  {: gci.insertarTerceto("Find",new Terceto(id.toString())); :};
factor ::= INTEGER_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto(constant.toString())); :};
factor ::= SUB INTEGER_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto( "-" + constant.toString())); :};
factor ::= FLOAT_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto(constant.toString())); :};
factor ::= SUB FLOAT_CONSTANT:constant {: gci.insertarTerceto("Find",new Terceto( "-" + constant.toString())); :};
factor ::= OPEN_BRACKET {: gci.eStack.push(gci.GCIVariables.get("Eind"));
                           gci.tStack.push(gci.GCIVariables.get("Tind"));:} expression:e CLOSE_BRACKET {: gci.asignarVarind("Find","Eind"); gci.asignarVarind("Eind", gci.eStack); gci.asignarVarind("Tind", gci.tStack); :};
